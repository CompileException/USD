/******************************************************************************
 * Copyright 1986, 2017 NVIDIA Corporation. All rights reserved.
 ******************************************************************************/

/*
THE MDL MATERIALS ARE PROVIDED PURSUANT TO AN END USER LICENSE AGREEMENT, WHICH WAS ACCEPTED IN ORDER TO GAIN ACCESS TO THIS FILE. IN PARTICULAR, THE MDL MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL,  INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE MDL MATERIALS OR FROM OTHER DEALINGS IN THE MDL MATERIALS
*/

mdl 1.2;
//    anno::version_number(0,1,10,0),

import df::*;
import state::*;
import math::*;
import base::*;
import tex::*;
import anno::*;


export using base import texture_return;
export using base import mono_mode;
export using base import color_layer_mode;

export enum material_type
[[
    anno::description("used to annotate materials as hint for grouping in the ui"),
    anno::hidden()
]]
{
    simple_material
        [[ anno::description("Simple material") ]],
    complex_material
        [[ anno::description("Complex material") ]],
    combiner_material
        [[ anno::description("Combiner material") ]],
    modifier_material
        [[ anno::description("Material modifier") ]]
};

export enum emission_type
[[
    anno::description("Used in light sources to define the emission mode"),
    anno::hidden()
]]
{
    lumen_m2
        [[ anno::description("lumen/m2") ]],
    lumen
        [[ anno::description("lumen") ]],
    candela
        [[ anno::description("candela") ]],
    nit
        [[ anno::description("nit (candela/m2)") ]]
};

export enum cell_type
[[
    anno::description("used to define the behavior of Worley noise"),
    anno::hidden()
]]
{
    simple_cells = 0
        [[ anno::description("Simple Cells") ]],
    crystal_cells = 1
        [[ anno::description("Crystal cells") ]],
    bordered_cells = 2
        [[ anno::description("Bordered cells") ]]
};

export enum cell_base
[[
    anno::description("used to annotate materials as hint for grouping in the ui"),
    anno::hidden()
]]
{
    circular_cells = 0
        [[ anno::description("Circle base") ]],
    diamond_cells = 1
        [[ anno::description("Diamond base") ]]
};

uniform float4x4 rotation_translation_scale(
    uniform float3 rotation = float3(0.)
        [[ anno::description("Rotation applied to every UVW coordinate") ]],
    uniform float3 translation = float3(0.)
        [[ anno::description("Offset applied to every UVW coordinate") ]],
    uniform float3 scaling = float3(1.)
        [[ anno::description("Scale applied to every UVW coordinate") ]]
)
[[
    anno::description("Construct transformation matrix from Euler rotation, translation and scale"),
    anno::hidden()
]]
{
    float4x4 scale =
        float4x4(scaling.x        , 0.               , 0.               , 0.,
                 0.               , scaling.y        , 0.               , 0.,
                 0.               , 0.               , scaling.z        , 0.,
                 translation.x, translation.y, translation.z, 1.);

    float3 s = math::sin(rotation);
    float3 c = math::cos(rotation);
    float4x4 rotate =
        float4x4(  c.y*c.z ,  -c.x*s.z + s.x*s.y*c.z ,  s.x*s.z + c.x*s.y*c.z , 0.0,
                   c.y*s.z ,   c.x*c.z + s.x*s.y*s.z , -s.x*c.z + c.x*s.y*s.z , 0.0,
                  -s.y     ,   s.x*c.y               ,  c.x*c.y               , 0.0,
                   0.     ,   0                   ,  0                   , 1.);

    return   scale*rotate;
}


export annotation suitable_as_light();
export annotation type_of_material(material_type type);
export annotation ui_position(int position);
export annotation typical_object_size(float size);

const string COPYRIGHT = "THE MDL MATERIALS ARE PROVIDED PURSUANT TO AN END USER LICENSE AGREEMENT, WHICH WAS ACCEPTED IN ORDER TO GAIN ACCESS TO THIS FILE. IN PARTICULAR, THE MDL MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL,  INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE MDL MATERIALS OR FROM OTHER DEALINGS IN THE MDL MATERIALS";


export texture_return blend_colors(
    color color_1 = color(0.0)
    [[ anno::display_name("Color 1") ]],
    color color_2 = color(1.0)
    [[ anno::display_name("Color 2") ]],
    uniform color_layer_mode mode = color_layer_blend
    [[
        anno::description("Describes how Color 1 and Color 2 are combined"),
        anno::display_name("Blend mode")
    ]],
    float weight = 1.
    [[
        anno::description("Defines strength of the effect. At weight of 0, only color 1 will be visible. At weight 1, the blend function will have full effect"),
        anno::display_name("Blend weight")
    ]]
)
[[
    anno::display_name("Blend colors"),
    anno::description("Allows combining textures in varied ways"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::blend_color_layers(
        layers: base::color_layer[](
            base::color_layer(
                layer_color: color_2,
                weight: weight,
                mode: mode
                )),
        base: color_1
    );
}

export texture_return file_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("Bitmap parameters"),
        ui_position(0)
    ]],
    uniform mono_mode mono_source = mono_average
    [[
        anno::display_name("Scalar mode"),
        anno::description("Defines how the texture applies to scalar parameters"),
        anno::in_group("Bitmap parameters"),
        ui_position(1)
    ]],
    uniform float brightness = 1.
    [[
        anno::display_name("Brightness"),
        anno::in_group("Bitmap parameters"),
        ui_position(2)
    ]],
    uniform float contrast = 1.
    [[
        anno::display_name("Contrast"),
        anno::in_group("Bitmap parameters"),
        ui_position(3)
    ]],
    uniform float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture, color will be black and the scalar value will be 0"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform bool invert = false
    [[
        anno::description("Invert image"),
        anno::display_name("Invert image"),
        anno::in_group("Bitmap parameters"),
        ui_position(4)
    ]]
)
[[
    anno::display_name("Bitmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return invert == false? base::file_texture(
        texture: texture,
        mono_source: mono_source,
        color_offset: color(0.5*brightness-0.5*contrast*brightness),
        color_scale: color(brightness*contrast),
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clip:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clip:tex::wrap_repeat
    ): base::file_texture(
        texture: texture,
        mono_source: mono_source,
        color_offset: color(1.0-0.5*brightness+0.5*contrast*brightness),
        color_scale: color(-brightness*contrast),
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clip:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clip:tex::wrap_repeat
    );
}

export texture_return perlin_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform int noise_levels = 3.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(6)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(5)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(11)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(10)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(8)
    ]]
)
[[
    anno::display_name("Perlin noise texture"),
    anno::description("Allow texturing with a random noise pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::perlin_noise_texture(
        color1: color1,
        color2: color2,
        noise_levels: noise_levels,
        absolute_noise: absolute_noise,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,

                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 perlin_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform int noise_levels = 1.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(6)
    ]]
)
[[
    anno::display_name("Perlin noise texture"),
    anno::description("Allows texturing a random noise pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::perlin_noise_bump_texture(
        factor: factor,
        noise_levels: noise_levels,
        absolute_noise: absolute_noise,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return worley_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space") ,
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform cell_type mode = simple_cells
    [[
        anno::display_name("Cell type") ,
        anno::description("Cell pattern type"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform cell_base metric = circular_cells
    [[
        anno::display_name("Cell shape") ,
        anno::description("The shape of the cell form"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(5)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(10)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(8)
    ]])
[[
    anno::display_name("Cellular noise texture"),
    anno::description("Allow texturing with a cell forming pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::worley_noise_texture(
        color1: color1,
        color2: color2,
        mode: mode==crystal_cells?2:mode==bordered_cells?3:0,
        metric: metric,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 worley_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    uniform cell_base metric = circular_cells
    [[
        anno::display_name("Cell shape") ,
        anno::description("The shape of the cell form"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(4)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(6)
    ]])
[[
    anno::display_name("Cellular noise texture"),
    anno::description("Allow texturing with a cell forming pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::worley_noise_bump_texture(
        factor: factor,
        metric: metric,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return flow_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(10)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(11)
    ]],
    uniform int noise_levels = 3.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(3)

    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(4)

    ]],
    uniform float phase = 0.0
    [[
        anno::display_name("Phase offset"),
        anno::description("Controls the 3rd dimension of the function"),
        anno::in_group("Noise parameters")
        ,
        ui_position(5)
    ]],
    uniform float level_gain = 0.5
    [[
        anno::display_name("Level intensity gain"),
        anno::description("If multiple levels are used, \"level_gain\" specifies a weighting factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(6)
    ]],
    uniform float level_scale = 2.0
    [[
        anno::display_name("Level scaling"),
        anno::description("If multiple levels are used, \"level_scale\" specifies a global scaling factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(7)
    ]],
    uniform float level_progressive_u_scale = 1.
    [[
        anno::display_name("Progressive u scale"),
        anno::description("If multiple levels are used, \"level_progressive_u_scale\" specifies an additional scaling factor in the \"u\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(8)
    ]],
    uniform float level_progressive_v_motion = 0.
    [[
        anno::display_name("Progressive v offset"),
        anno::description("If multiple levels are used, \"level_progressive_v_motion\" specifies an offset for subsequent levels in the \"v\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(9)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(15)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(14)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(13)
    ]])
[[
    anno::display_name("Flow noise texture"),
    anno::description("Allow texturing with a 2D noise pattern suitable for waves"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::flow_noise_texture(
        color1: color1,
        color2: color2,
        levels: noise_levels,
        phase: phase,
        level_gain: level_gain,
        level_scale: level_scale,
        level_progressive_u_scale: level_progressive_u_scale,
        level_progressive_v_motion: level_progressive_v_motion,
        absolute_noise: absolute_noise,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 flow_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(12)
    ]],
    uniform int noise_levels = 1.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform float phase = 0.0
    [[
        anno::display_name("Phase offset"),
        anno::description("Controls the 3rd dimension of the function"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float level_gain = 0.5
    [[
        anno::display_name("Level intensity gain"),
        anno::description("If multiple levels are used, \"level_gain\" specifies a weighting factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float level_scale = 2.0
    [[
        anno::display_name("Level scaling"),
        anno::description("If multiple levels are used, \"level_scale\" specifies a global scaling factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(5)
    ]],
    uniform float level_progressive_u_scale = 1.
    [[
        anno::display_name("Progressive u scale"),
        anno::description("If multiple levels are used, \"level_progressive_u_scale\" specifies an additional scaling factor in the \"u\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(6)
    ]],
    uniform float level_progressive_v_motion = 0.
    [[
        anno::display_name("Progressive v offset"),
        anno::description("If multiple levels are used, \"level_progressive_v_motion\" specifies an offset for subsequent levels in the \"v\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(7)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(11)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(10)
    ]])
[[
    anno::display_name("Flow noise texture"),
    anno::description("Allow texturing with a 2D noise pattern suitable for waves"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::flow_noise_bump_texture(
        factor: factor,
        levels: noise_levels,
        phase: phase,
        level_gain: level_gain,
        level_scale: level_scale,
        level_progressive_u_scale: level_progressive_u_scale,
        level_progressive_v_motion: level_progressive_v_motion,
        absolute_noise: absolute_noise,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return checker_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Checker parameters"),
        ui_position(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Checker parameters"),
        ui_position(1)
    ]],
    uniform float3 scaling = float3(10.)
     [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(3)
    ]],
    uniform float blur = 0
    [[
        anno::hard_range(0.0,1.0),
        anno::display_name("Blur"),
        anno::in_group("Checker parameters"),
        ui_position(2)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(4)
    ]]
)
[[
    anno::display_name("3d checker texture"),
    anno::description("Allows texturing a checkerboard pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::checker_texture(
        color1: color1,
        color2: color2,
        blur: blur/4.,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 checker_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Checker parameters"),
        ui_position(0)
    ]],
    uniform float blur = 0
    [[
        anno::hard_range(0.0,1.0),
        anno::display_name("Blur"),
        anno::in_group("Checker parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(2)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(4)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(3)
    ]]
)
[[
    anno::display_name("3d checker texture"),
    anno::description("Allows texturing a checkerboard pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::checker_bump_texture(
        factor: factor,
        blur: blur/4.,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 file_bump_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("Bitmap parameters"),
        ui_position(1)
    ]],
    uniform mono_mode bump_source = mono_average
    [[
        anno::display_name("Bump mode"),
        anno::description("Defines how the texture is evaluated to create the bumps"),
        anno::in_group("Bitmap parameters"),
        ui_position(2)
    ]],
    uniform float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture the surface will be flat"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        ui_position(5)

    ]],
    uniform float factor = 1
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Bitmap parameters"),
        ui_position(3)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(4)
    ]]
)
[[
    anno::display_name("Bitmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::file_bump_texture(
        texture: texture,
        bump_source: bump_source,
        factor: factor,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clamp:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clamp:tex::wrap_repeat,
        clip: clip
    );
}

export float3 normalmap_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Normalmap file"),
        anno::in_group("Normalmap parameters"),
        ui_position(1)
    ]],
    uniform float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture the surface will be flat"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        ui_position(4)

    ]],
    uniform float factor = 1
    [[
        anno::display_name("Strength"),
        anno::in_group("Normalmap parameters"),
        ui_position(2)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(3)
    ]]
)
[[
    anno::display_name("Normalmap texture"),
    anno::description("Allows the use of tangent space normal maps"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::tangent_space_normal_texture(
        texture: texture,
        factor: factor,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clamp:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clamp:tex::wrap_repeat,
        clip: clip
    );
}

export float dummy_float_function() {return 3.14;}

// A simple struct.
export struct example_struct {
    int param_int;
    float param_float = 0.0;
};

// A complex struct which references another struct.
export struct complex_struct {
    int param_int;
    example_struct param_struct;
};

//material section
//export
material testMaterial(
	bool test_bool,
	int test_int = 2
)
 =  material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            layer: df::diffuse_reflection_bsdf(
                    roughness: 1,
                    tint: color(.8)
            )
        )
    )
);

export
material materialWithEnum(
  uniform color_layer_mode mode = color_layer_blend

) =  material();

// A simple struct.
//export
struct simple_struct {
    int paramInt;
    float paramFloat = 0.0;
};

//export
material materialWithStructure(
  simple_struct structInput = simple_struct(1, 2.0),
  uniform texture_2d test_texture = texture_2d("./dummy.jpg", ::tex::gamma_default)

) =  material();

//export
material simpleMaterial(
    int param_int = 1,
    float param_float = 2.0
) =  material();

//export
material materialWithMaterialInput(
  material materialInput = simpleMaterial()
) =  material();

export
material diffuse(
	
    // Test simple types
	bool test_bool = true,
	int test_int = true,
	material_type test_enum = complex_material,
	float roughness = 0.0
    [[
        anno::display_name("Diffuse roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead a powdery appearance")
    ]],
	double test_double = 3.14,
	string test_string = "Test string",
    color diffuse_color = color(.8)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material")
    ]],
	uniform texture_2d test_texture = texture_2d("./dummy.jpg", ::tex::gamma_default),

	// Test vectors
	// MDL provides two, three, and four component vector types with either float, double, int, or bool
	// component types. Vectors are named by taking the component type name and appending the dimension
	// of the vector, which can be 2, 3, or 4.
	bool2 test_bool2 = bool2(true,false),
	bool3 test_bool3 = bool3(true),
	bool4 test_bool4 = bool4(true),
	int2 test_int2 = int2(1,2),
	int3 test_int3 = int3(3),
	int4 test_int4 = int4(4),
	float2 test_float2 = float2(1.0,2.0),
	float3 test_float3 = float3(3.0),
	float4 test_float4 = float4(4.0),
	double2 test_double2 = double2(1.0,2.0),
	double3 test_double3 = double3(3.0),
	double4 test_double4 = double4(4.0),	

	// Test matrices
	// built-in matrix types are: float2x2, float2x3, float3x2, float3x3, float3x4, float4x2,
	// float2x4, float4x3, float4x4, double2x2, double2x3, double3x2, double3x3, double3x4, double4x2,
	// double2x4, double4x3, and double4x4.
	float2x2 test_float2x2 = float2x2(1,2,3,4),
	float3x3 test_float3x3 = float3x3(1),
	float4x4 test_float4x4 = float4x4(2),
	float3x2 test_float3x2 = float3x2(1), // Error, not supported
	double2x2 test_double2x2 = double2x2(2),
	double3x3 test_double3x3 = double3x3(2),
	double4x4 test_double4x4 = double4x4(2),
	
	// Test arrays of simple types
	bool[4] bool_array = bool[](true,false,true,false),
	int[4] int_array = int[](1,2,3,4),
	float[4] float_array = float[](1.0,2.0,3.0,4.0),
	double[4] double_array = double[](1.0,2.0,3.0,4.0),
	string[4] string_array = string[]("1.0","2.0","3.0","4.0"),
	color[4] color_array = color[](color(.8),color(.8),color(.8),color(.8)),

	// Test arrays of vectors
	bool2[2] bool2_array_of_vectors = bool2[](bool2(true,false),bool2(false,true)),
	bool3[2] bool3_array_of_vectors = bool3[](bool3(true,false, false),bool3(false,true,true)),
	bool4[2] bool4_array_of_vectors = bool4[](bool4(true,false, false, false),bool4(false,true,true,true)),
	int2[2] int2_array_of_vectors = int2[](int2(1,2),int2(3,4)),
	int3[2] int3_array_of_vectors = int3[](int3(1,2,3),int3(4,5,6)),
	int4[2] int4_array_of_vectors = int4[](int4(1,2,3,4),int4(5,6,7,8)),
	float2[3] float2_array_of_vectors = float2[](float2(1.0,2.0),float2(3.0,4.0),float2(5.0,6.0)),
	float3[3] float3_array_of_vectors = float3[](float3(1.0,2.0,2.5),float3(3.0,4.0,4.5),float3(5.0,6.0,6.5)),
	float4[3] float4_array_of_vectors = float4[](float4(1.0,2.0,2.5,2.6),float4(3.0,4.0,4.5,4.6),float4(5.0,6.0,6.5,6.6)),
	double2[2] double2_array_of_vectors = double2[](double2(5,6),double2(7,8)),
	double3[2] double3_array_of_vectors = double3[](double3(5,6,7),double3(7,8,9)),
	double4[2] double4_array_of_vectors = double4[](double4(5,6,7,8),double4(7,8,9,10)),
	
	// Test function call
	texture_return file_tex = file_texture(texture: texture_2d("./dummy.jpg")),
	float3 perlin_parm = perlin_noise_bump_texture(dummy_float_function()),
	
	// Test structure
	example_struct test_struct = example_struct(1,1.0),
//	complex_struct test_struct2 = complex_struct(),
//	example_struct test_struct = example_struct(),
	
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Simple diffuse"),
    anno::description("A basic diffuse material"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    anno::version_number(0,1,9,0),
    type_of_material(simple_material),
    typical_object_size(1.0),
   anno::key_words(string[]("generic"))
]]
 =  material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::diffuse_reflection_bsdf(
                    roughness: roughness,
                    tint: diffuse_color
            )
        )
    )
);

